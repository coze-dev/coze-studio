/*
 * Copyright 2025 coze-dev Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck

import * as common from './common';
import * as base from './base';

export type Int64 = string | number;

export enum AppendType {
  /** Occupancy */
  SegmentAppendType_None = 0,
  /** tail append */
  SegmentAppendType_Tail = 1,
}

export enum ColumnType {
  Unknown = 0,
  /** Text */
  Text = 1,
  /** number */
  Number = 2,
  /** time */
  Date = 3,
  /** float */
  Float = 4,
  /** bool */
  Boolean = 5,
  /** picture */
  Image = 6,
}

export enum TableDataType {
  /** Schema sheets and preview data */
  AllData = 0,
  /** Only need schema structure & Sheets */
  OnlySchema = 1,
  /** Just preview the data */
  OnlyPreview = 2,
}

export interface AuthFrequencyInfo {
  auth_id: string;
  auth_frequency_type: common.FrequencyType;
  auth_name?: string;
}

export interface BatchSubmitWebUrlRequest {
  web_urls?: Array<string>;
  Base?: base.Base;
}

export interface BatchSubmitWebUrlResponse {
  web_ids?: Array<string>;
  code: Int64;
  msg: string;
  BaseResp?: base.BaseResp;
}

export interface BatchUpdateDocumentRequest {
  document_ids?: Array<string>;
  update_rule?: UpdateRule;
  Base?: base.Base;
}

export interface BatchUpdateDocumentResponse {
  /** Deprecated is compatible with older interfaces and will be returned when content is updated. */
  document_info?: Array<DocumentInfo>;
  code?: Int64;
  msg?: string;
  BaseResp?: base.BaseResp;
}

/** The content obtained by the front-end crawler plug-in */
export interface CrawlContent {
  /** title */
  title?: string;
  /** header */
  headers?: Array<string>;
  /** Full information captured */
  content?: Array<Record<string, string>>;
  /** URL of the crawl page */
  url?: string;
  /** XPATH for crawling information */
  marks?: Record<string, string>;
  /** The type of tag stored, the type is Array < 'text' | 'image' | 'link' >, which corresponds to headers one-to-one */
  tags?: Array<string>;
  /** New paging configuration */
  pagination?: Pagination;
  /** The XPATH of the subpage fetch information, the key corresponds to the key in marks */
  sub_marks?: Record<string, Record<string, string>>;
}

export interface CreateDocumentRequest {
  dataset_id?: string;
  format_type?: common.FormatType;
  /** Only one table type can be created at a time
Document information to be created */
  document_bases?: Array<DocumentBase>;
  /** Only when there is no document in the knowledge base, it needs to be passed, and if there is one, it will be obtained from the knowledge base. Slicing rules, if it is empty, it will be automatically sliced according to paragraphs. See IDP for specific rules: */
  chunk_strategy?: common.ChunkStrategy;
  /** Drop library rules when data is imported */
  sink_strategy?: common.SinkStrategy;
  /** Whether it is additional content, used to add content to the table
Appends content to an existing document when true. The text type cannot be used */
  is_append?: boolean;
  /** parsing strategy */
  parsing_strategy?: common.ParsingStrategy;
  index_strategy?: common.IndexStrategy;
  storage_strategy?: common.StorageStrategy;
  Base?: base.Base;
}

export interface CreateDocumentResponse {
  document_infos?: Array<DocumentInfo>;
  code?: number;
  msg?: string;
  BaseResp: base.BaseResp;
}

export interface DeleteDocumentRequest {
  document_ids?: Array<string>;
  /** Since the volcanic side document is a non-numeric string, this field stores the new knowledge base id, and the server level will be aggregated document_ids and then deduplicated */
  document_ids_new?: Array<string>;
  /** It is used to distinguish whether it is a volcano knowledge base. If it is not transmitted, it defaults to coze knowledge base. */
  dataset_id?: string;
  Base?: base.Base;
}

export interface DeleteDocumentResponse {
  code?: Int64;
  msg?: string;
  BaseResp: base.BaseResp;
}

export interface DocTableSheet {
  /** Number of sheet */
  id?: Int64;
  /** Sheet name */
  sheet_name?: string;
  /** total number of rows */
  total_row?: Int64;
}

/** Basic information for creating a document */
export interface DocumentBase {
  name?: string;
  source_info?: SourceInfo;
  /** API type update configuration, other types do not need to pass */
  update_rule?: UpdateRule;
  /** The following parameter table types need to be passed
Table metadata */
  table_meta?: Array<TableColumn>;
  /** Table parsing information */
  table_sheet?: TableSheet;
  /** filtering strategy */
  filter_strategy?: common.FilterStrategy;
  /** Image type, picture description when manually annotated, currently only supports openapi calls */
  caption?: string;
  /** Volcano Knowledge Base, < tag signature, tag value > */
  volcano_tab_kv?: Record<string, common.TabValue>;
}

/** Provide only the fields in the Document table. Do not add other fields that require cross-table or RPC calls to obtain them. */
export interface DocumentBrief {
  /** When updating, it will not be updated even if it is transmitted. */
  id?: Int64;
  /** Updated fields used by flink
File suffix csv, pdf, etc */
  type?: string;
  /** File size, number of bytes */
  size?: number;
  /** number of segments included */
  slice_count?: number;
  /** character count */
  char_count?: number;
  /** state */
  status?: common.DocumentStatus;
  /** JSON format string */
  sink_status?: string;
  dataset_id?: Int64;
  format_type?: common.FormatType;
  space_id?: Int64;
}

export interface DocumentInfo {
  name?: string;
  document_id?: string;
  /** file link */
  tos_uri?: string;
  /** Number of bots deprecated */
  bot_used_count?: number;
  /** creation time */
  create_time?: number;
  /** update time */
  update_time?: number;
  /** founder */
  creator_id?: string;
  /** number of segments included */
  slice_count?: number;
  /** File suffix csv, pdf, etc */
  type?: string;
  /** File size, number of bytes */
  size?: number;
  /** character count */
  char_count?: number;
  /** state */
  status?: common.DocumentStatus;
  /** hit count */
  hit_count?: number;
  /** source */
  source_type?: common.DocumentSource;
  /** update type */
  update_type?: common.UpdateType;
  /** update interval */
  update_interval?: number;
  /** file type */
  format_type?: common.FormatType;
  /** Table type metadata */
  table_meta?: Array<TableColumn>;
  /** URL address */
  web_url?: string;
  /** Details of the status; if the slice fails, return the failure information */
  status_descript?: string;
  source_file_id?: string;
  is_disconnect?: boolean;
  space_id?: string;
  /** The following fields are only useful for the reconstructed table type and are used for front-end judgment
Only for table types, is it allowed to edit the update frequency? */
  editable_update_rule?: boolean;
  /** Only for table types, are you allowed to add content and modify the table structure? */
  editable_append_content?: boolean;
  /** slicing rule */
  chunk_strategy?: common.ChunkStrategy;
  /** File links stored by ImageX */
  imagex_uri?: string;
  /** Hierarchical Segmentation Document Tree Json (unused) */
  doc_outline?: string;
  /** parsing strategy */
  parsing_strategy?: common.ParsingStrategy;
  index_strategy?: common.IndexStrategy;
  filter_strategy?: common.FilterStrategy;
  /** Hierarchical segmented document tree tos_url */
  doc_tree_tos_url?: string;
  /** Preview the original document tos_url */
  preview_tos_url?: string;
  /** Preview the original document tos_url */
  review_id?: Int64;
  /** Since the volcanic side document is a non-numeric string, add this field to return the string type */
  document_id_new?: string;
}

export interface DocumentProgress {
  document_id?: string;
  progress?: number;
  status?: common.DocumentStatus;
  /** A detailed description of the status; if the slice fails, a failure message is returned */
  status_descript?: string;
  document_name?: string;
  remaining_time?: Int64;
  size?: Int64;
  type?: string;
  url?: string;
  /** update type */
  update_type?: common.UpdateType;
  /** update interval */
  update_interval?: number;
}

export interface ExtractPhotoCaptionRequest {
  document_id: string;
  Base?: base.Base;
}

export interface ExtractPhotoCaptionResponse {
  caption?: string;
  code?: Int64;
  msg?: string;
}

export interface FetchWebUrlRequest {
  document_ids?: Array<string>;
  Base?: base.Base;
}

export interface FetchWebUrlResponse {
  code: Int64;
  msg: string;
  BaseResp?: base.BaseResp;
}

export interface GetAppendFrequencyRequest {
  dataset_id: string;
  Base?: base.Base;
}

export interface GetAppendFrequencyResponse {
  auth_frequency_info: Array<AuthFrequencyInfo>;
  code: Int64;
  msg: string;
}

export interface GetDocumentProgressRequest {
  document_ids?: Array<string>;
  Base?: base.Base;
}

export interface GetDocumentProgressResponse {
  data?: Array<DocumentProgress>;
  code: Int64;
  msg: string;
  BaseResp?: base.BaseResp;
}

export interface GetTableSchemaRequest {
  /** Table parsing information, default initial value 0, 0, 1 */
  table_sheet?: TableSheet;
  /** All data is returned by default without passing it on. */
  table_data_type?: TableDataType;
  /** Compatible with pre-refactoring versions: pass this value if you need to pull the schema of the current document */
  document_id?: string;
  /** Source file information, add segment/before logic migrate here */
  source_file?: SourceInfo;
  /** The table preview front end needs to pass the original data table structure */
  origin_table_meta?: Array<TableColumn>;
  /** The table preview front end needs to pass the data table structure edited by the user */
  preview_table_meta?: Array<TableColumn>;
  Base?: base.Base;
}

export interface GetTableSchemaResponse {
  code?: number;
  msg?: string;
  sheet_list?: Array<DocTableSheet>;
  /** The schema of the selected sheet, not selected to return the first sheet by default */
  table_meta?: Array<TableColumn>;
  /** The knowledge table will return */
  preview_data?: Array<Record<Int64, string>>;
}

export interface GetWebInfoRequest {
  web_ids?: Array<string>;
  /** Does it contain content? */
  include_content?: boolean;
  Base?: base.Base;
}

export interface GetWebInfoResponse {
  data?: Record<Int64, RootWebData>;
  code: Int64;
  msg: string;
  BaseResp?: base.BaseResp;
}

export interface ListDocumentRequest {
  dataset_id: string;
  document_ids?: Array<string>;
  page?: number;
  size?: number;
  /** Search by name */
  keyword?: string;
  Base?: base.Base;
}

export interface ListDocumentResponse {
  document_infos?: Array<DocumentInfo>;
  total?: number;
  code?: Int64;
  msg?: string;
  BaseResp: base.BaseResp;
}

export interface ListModelRequest {
  Base?: base.Base;
}

export interface ListModelResponse {
  models: Array<ModelInfo>;
  BaseResp: base.BaseResp;
}

export interface ListPhotoRequest {
  dataset_id: string;
  /** Number of pages, starting from 1 */
  page?: number;
  size?: number;
  filter?: PhotoFilter;
  Base?: base.Base;
}

export interface ListPhotoResponse {
  photo_infos?: Array<PhotoInfo>;
  total?: number;
  code?: Int64;
  msg?: string;
}

export interface ModelInfo {
  name?: string;
}

export interface Pagination {
  /** Maximum number of items collected by list type */
  max_row_count?: number;
  /** Paging method: 0-no paging 1-scroll loading 2-next page button */
  type?: number;
  /** When the type is 2, the next button that needs to store the user tag */
  next_page_xpath?: string;
}

export interface PhotoDetailRequest {
  document_ids: Array<string>;
  dataset_id: string;
  Base?: base.Base;
}

export interface PhotoDetailResponse {
  photo_infos?: Record<Int64, PhotoInfo>;
  code?: Int64;
  msg?: string;
}

export interface PhotoFilter {
  /** True to filter "marked" images, false to filter "unmarked" images */
  has_caption?: boolean;
  /** Search keywords, search for image names and picture descriptions */
  keyword?: string;
  /** state */
  status?: common.DocumentStatus;
}

export interface PhotoInfo {
  name?: string;
  document_id?: string;
  /** image link */
  url?: string;
  /** picture description information */
  caption?: string;
  /** creation time */
  create_time?: number;
  /** update time */
  update_time?: number;
  /** founder */
  creator_id?: string;
  /** Image suffix jpg, png, etc */
  type?: string;
  /** image size */
  size?: number;
  /** state */
  status?: common.DocumentStatus;
  /** source */
  source_type?: common.DocumentSource;
}

export interface RefreshDocumentRequest {
  dataset_id?: string;
  document_id?: string;
  /** segmentation strategy */
  chunk_strategy?: common.ChunkStrategy;
  Base?: base.Base;
}

export interface RefreshDocumentResponse {
  /** Returns the documentID of the newly generated document. */
  document_id?: string;
  code?: Int64;
  msg?: string;
  BaseResp?: base.BaseResp;
}

export interface ResegmentRequest {
  dataset_id?: string;
  /** Interface to be re-segmented */
  document_ids?: Array<string>;
  /** segmentation strategy */
  chunk_strategy?: common.ChunkStrategy;
  /** Pre-sliced review ID list */
  review_ids?: Array<string>;
  /** parsing strategy */
  parsing_strategy?: common.ParsingStrategy;
  index_strategy?: common.IndexStrategy;
  filter_strategy?: common.FilterStrategy;
  Base?: base.Base;
}

export interface ResegmentResponse {
  /** The old version requires. Just return the id and name. */
  document_infos?: Array<DocumentInfo>;
  code?: Int64;
  msg?: string;
  BaseResp?: base.BaseResp;
}

export interface RootWebData {
  progress?: number;
  web_info?: WebInfo;
  status?: common.WebStatus;
  status_descript?: string;
}

export interface SetAppendFrequencyRequest {
  auth_frequency_info: Array<AuthFrequencyInfo>;
  dataset_id: string;
  Base?: base.Base;
}

export interface SetAppendFrequencyResponse {
  code: Int64;
  msg: string;
}

/** Supports multiple data sources */
export interface SourceInfo {
  /** document_source Local, Feishu: TOS address for file upload */
  tos_uri?: string;
  /** document_source weburl, passing on web_id created through knowledge */
  web_id?: string;
  /** document_source google, notion: tripartite source id
document_source openapi: openapi uploaded file id */
  source_file_id?: string;
  document_source?: common.DocumentSource;
  /** document_source custom original content: json list < map < string, string > > */
  custom_content?: string;
  /** document_source front-end crawling: pass the content obtained by the front-end crawling plug-in */
  crawl_content?: CrawlContent;
  /** document_source local: If you don't send the tos address, you need to send the file base64, type
File string after base64 */
  file_base64?: string;
  /** File type, such as PDF */
  file_type?: string;
  /** document_source weburl: If you don't pass web_id, you need to pass weburl */
  web_url?: string;
  /** imagex_uri, and tos_uri choose one, imagex_uri priority, need to get data and sign url through imagex method */
  imagex_uri?: string;
  /** review_id: After the review ID after pre-slicing, it will directly take the pre-sliced result data vectorization, if not passed or passed 0, it will be re-sliced */
  review_id?: string;
}

export interface SubmitWebUrlRequest {
  web_url?: string;
  /** 0 does not replace subpages */
  subpages_count?: number;
  /** File format type */
  format_type?: common.FormatType;
  /** Page title url type required */
  title?: string;
  Base?: base.Base;
}

export interface SubmitWebUrlResponse {
  web_id?: string;
  code: Int64;
  msg: string;
  BaseResp?: base.BaseResp;
}

/** Table column information */
export interface TableColumn {
  /** Column ID */
  id?: string;
  /** listing */
  column_name?: string;
  /** Is it a semantically matched column? */
  is_semantic?: boolean;
  /** List the serial number originally in excel */
  sequence?: string;
  /** column type */
  column_type?: ColumnType;
  contains_empty_value?: boolean;
  /** describe */
  desc?: string;
}

export interface TableSheet {
  /** User selected sheet id */
  sheet_id?: string;
  /** The number of header rows selected by the user, numbered from 0 */
  header_line_idx?: string;
  /** User-selected starting line number, numbered from 0 */
  start_line_idx?: string;
}

export interface UpdateDocumentRequest {
  document_id?: string;
  /** The document is not enabled after refactoring, and it is used for the old interface. */
  status?: common.DocumentStatus;
  /** If you need to update, please upload it and update the name. */
  document_name?: string;
  /** web type
web type update configuration */
  update_rule?: UpdateRule;
  /** Update table structure
Table metadata */
  table_meta?: Array<TableColumn>;
  Base?: base.Base;
}

export interface UpdateDocumentResponse {
  /** Deprecated is compatible with older interfaces and will be returned when content is updated. */
  document_info?: DocumentInfo;
  code?: Int64;
  msg?: string;
  BaseResp?: base.BaseResp;
}

export interface UpdatePhotoCaptionRequest {
  document_id: string;
  /** Description information */
  caption: string;
  Base?: base.Base;
}

export interface UpdatePhotoCaptionResponse {
  code?: Int64;
  msg?: string;
}

export interface UpdateRule {
  /** update type */
  update_type?: common.UpdateType;
  /** Update interval, in days */
  update_interval?: number;
}

export interface ValidateTableSchemaRequest {
  space_id?: string;
  document_id?: string;
  /** Information from the source file */
  source_file?: SourceInfo;
  table_sheet?: TableSheet;
  Base?: base.Base;
}

export interface ValidateTableSchemaResponse {
  column_valid_result?: Record<string, string>;
  /** If it fails, an error code will be returned. */
  code: Int64;
  msg: string;
}

export interface WebInfo {
  id?: string;
  url?: string;
  content?: string;
  title?: string;
  subpages?: Array<WebInfo>;
  subpages_count?: number;
  status?: common.WebStatus;
}
/* eslint-enable */
