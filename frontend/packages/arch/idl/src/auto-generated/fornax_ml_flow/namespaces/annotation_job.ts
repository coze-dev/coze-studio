/*
 * Copyright 2025 coze-dev Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck

import * as filter from './filter';
import * as flow_devops_prompt_common from './flow_devops_prompt_common';
import * as batch_infer from './batch_infer';

export type Int64 = string | number;

export enum AIAnnotatorCategory {
  /** online */
  Online = 1,
  /** offline */
  Offline = 2,
}

export enum AnnotationType {
  /** Large model marking */
  AI = 1,
  /** regular marking */
  Rule = 2,
  /** manual marking */
  Manual = 3,
}

export enum CrowdsourcingAnnotateJobStatus {
  Undefined = 0,
  Sending = 1,
  In_Progress = 2,
  Abnormal = 3,
  Completed = 4,
  Terminated = 5,
}

export enum CrowdsourcingAnnotationPlatform {
  Undefined = 0,
  AIDP = 1,
  AIDP_Lite = 2,
}

export enum DataSelectScope {
  Undefined = 0,
  All = 1,
  Filtered = 2,
  Manually_Selected = 3,
}

export enum RuleAnnotatorCategory {
  /** python */
  Python = 1,
}

export enum ThinkingOutputBehavior {
  UNSPECIFIED = 0,
  WithoutThinking = 1,
  ThinkingToSpecifiedColumn = 2,
}

export interface AIAnnotator {
  /** This field has a different meaning from the PromptCategory in the inner layer, representing whether an existing evaluator is associated. This field is not currently used */
  category?: AIAnnotatorCategory;
  onlineAIAnnotator?: OnlineAIAnnotator;
  offlineAIAnnotator?: OfflineAIAnnotator;
}

export interface AIDPConfig {
  /** AIDP user ID */
  userID: string;
  /** AIDP Task ID */
  taskID: string;
  /** task name */
  taskName: string;
  /** Task details link, return field */
  taskURL?: string;
  answerSchema?: string;
}

export interface AIDPField {
  key?: string;
  name?: string;
}

export interface AIDPFlowNode {
  nodeID?: string;
  name?: string;
}

export interface AIDPTaskFlowConfig {
  nodes?: Array<AIDPFlowNode>;
  requiredFields?: Array<AIDPField>;
}

export interface AIDPTaskSummary {
  /** Task ID */
  taskID?: string;
  /** task name */
  title?: string;
  /** Project name */
  projectName?: string;
  /** Callback Configuration */
  callbackOpts?: CallbackOpts;
  /** Answer Template ID */
  templateID?: string;
  /** task link */
  taskURL?: string;
}

export interface AnnotateStatusDetail {
  /** total data volume */
  inputSize?: string;
  /** amount of data sent */
  sent?: string;
  /** scalded data volume */
  received?: string;
}

export interface AnnotationConfig {
  /** label task type */
  annotationType?: AnnotationType;
  /** Large model marker configuration */
  aiAnnotator?: AIAnnotator;
  /** Rule marker configuration */
  ruleAnnotator?: RuleAnnotator;
}

export interface AnnotationJob {
  /** primary key ID */
  id?: string;
  appId?: string;
  spaceId?: string;
  /** JobID */
  annotationJobId?: string;
  jobDomain?: string;
  targetID?: string;
  /** Version of the task, non-dataset version */
  version?: string;
  /** Status: active/inactive */
  status?: string;
  name?: string;
  annotationConfig?: AnnotationConfig;
  targetResourceName?: string;
  extra?: string;
  /** general information */
  createdAt?: string;
  createdBy?: string;
  updatedAt?: string;
  updatedBy?: string;
}

export interface AnnotationJobRunInstance {
  /** Job instance ID generated after running */
  annotationJobRunID?: string;
  /** total number of articles */
  total?: number;
  /** number of successes */
  successCnt?: number;
  /** number of failures */
  failedCnt?: number;
  /** Task status, running/success/failed/canceled/partial_success */
  status?: string;
  /** Returns only on the GetAnnotationJobProcess interface to poll the marking task associated with the query output column */
  outputFieldKeys?: Array<string>;
  /** JobID non-ID */
  jobID?: string;
  job?: AnnotationJob;
  createdBy?: string;
  createdAt?: string;
  endAt?: string;
  runLog?: AnnotationJobRunLog;
}

export interface AnnotationJobRunLog {
  /** error log */
  errorMsg?: string;
  /** Jump links for offline tasks */
  offlineJobProviderUrl?: string;
}

export interface Annotator {
  /** Type: manual, associated */
  category?: string;
  /** manual configuration */
  manualAnnotator?: ManualAnnotator;
}

export interface CallbackOpts {
  CallbackType?: string;
}

export interface CrowdsourcingAnnotateInputConfig {
  /** Enter the dataset ID */
  inputDatasetID: string;
  /** Enter a dataset name */
  inputDatasetName: string;
  /** Input dataset version */
  inputDatasetVersionNum: string;
  /** Input dataset Veriosn primary key */
  inputDatasetVersionID: string;
  /** Three-paragraph version number return field */
  inputDatasetVersion?: string;
  /** itemID that needs to be annotated with data */
  itemIDs?: Array<Int64>;
  /** Data filtering conditions, to be determined, see the specific implementation of the label */
  filter?: filter.Filter;
  /** Return field */
  fieldMeta?: filter.FieldMetaInfoData;
  /** Return field */
  total?: number;
  /** Send data field mapping configuration */
  inputMappings: Array<InputMapping>;
  /** data range */
  dataSelectScope?: DataSelectScope;
}

export interface CrowdsourcingAnnotateJob {
  /** primary key */
  id?: string;
  name?: string;
  description?: string;
  platform?: CrowdsourcingAnnotationPlatform;
  /** AIDP configuration */
  aidpConfig?: AIDPConfig;
  /** feed configuration */
  inputConfig?: CrowdsourcingAnnotateInputConfig;
  /** bid configuration */
  outputConfig?: CrowdsourcingAnnotateOutputConfig;
  /** Data details The dataset ID stored */
  InternalDatasetID?: string;
  /** task status */
  status?: CrowdsourcingAnnotateJobStatus;
  /** Reason for failure */
  terminateReason?: string;
  /** mission progress */
  statusDetail?: AnnotateStatusDetail;
  /** creation time */
  createdAt?: string;
  /** Update time/end time */
  updatedAt?: string;
  /** founder */
  createdBy?: string;
}

export interface CrowdsourcingAnnotateOutputConfig {
  /** Whether to automatically bid */
  isAutoFetchRes: boolean;
  /** Whether to automatically output to a new dataset */
  isAutoExportToNewDataset: boolean;
  /** Output dataset name */
  outputDatasetName?: string;
  /** Output dataset ID return field */
  outputDatasetID?: string;
  /** Whether to disassemble and label the results */
  isParseAnnotateRes: boolean;
  /** output mapping */
  outputMappings?: Array<OutputMapping>;
}

export interface InputMapping {
  /** Input type: fixed value fixed, associated field use_column, previous input former_model_input, previous output former_model_output */
  sourceType?: string;
  /** input value */
  sourceValue?: string;
  /** Output type: prompt variable name prompt_var_name */
  targetType?: string;
  /** output value */
  targetValue?: string;
  /** If it is a column, this field can store the name. */
  sourceName?: string;
}

export interface ManualAnnotator {
  /** model configuration */
  model?: flow_devops_prompt_common.ModelConfig;
  /** Prompt type: manual, associated */
  promptCategory?: string;
  /** Manually populated data content */
  promptContent?: string;
  /** time of association */
  promptID?: string;
  /** time of association */
  promptVersion?: string;
  userPromptColumnName?: string;
  /** input mapping */
  inputMappings?: Array<InputMapping>;
  /** output mapping */
  outputMappings?: Array<OutputMapping>;
  /** Thinking output mapping to use when ThinkingOutputBehavior=ThinkingToSpecifiedColumn */
  thinkingOutputMapping?: OutputMapping;
}

export interface OfflineAIAnnotator {
  /** batch inference configuration
model source */
  batchInferprovider?: batch_infer.Provider;
  /** Model Configuration & Resource Configuration */
  batchInferProviderInfo?: batch_infer.ProviderInfo;
  /** model parameters */
  batchInferParam?: batch_infer.BatchInferParam;
  /** task configuration
Prompt type manual/associated/none */
  promptCategory?: string;
  /** Manually populated data content */
  promptContent?: string;
  /** time of association */
  promptID?: string;
  /** time of association */
  promptVersion?: string;
  userPromptColumnName?: string;
  /** input mapping */
  inputMappings?: Array<InputMapping>;
  /** output mapping */
  outputMappings?: Array<OutputMapping>;
  /** Marking null values only */
  onlyForEmpty?: boolean;
  /** Marking failures only */
  onlyForFailed?: boolean;
  /** Allow unconfigured label options */
  allowUndefinedTagValues?: boolean;
}

export interface OnlineAIAnnotator {
  /** tagger configuration */
  annotator?: Annotator;
  /** number of inferences */
  inferRound?: number;
  /** batch data volume */
  batchSize?: number;
  /** Marking null values only */
  onlyForEmpty?: boolean;
  /** Marking failures only */
  onlyForFailed?: boolean;
  /** Allow unconfigured label options */
  allowUndefinedTagValues?: boolean;
  /** automatic update */
  autoUpdate?: boolean;
  /** Marking concurrency */
  executeConcurrency?: number;
  /** Strategies for outputting model thinking processes */
  thinkingOutputBehavior?: ThinkingOutputBehavior;
}

export interface OutputMapping {
  /** Input Type: plain, json_path */
  sourceType?: string;
  /** input value */
  sourceValue?: string;
  /** Output type: use_column, plain */
  targetType?: string;
  /** output value */
  targetValue?: string;
  /** TargetType is use_column identifies whether a new column is created */
  isNewColumn?: boolean;
  /** Label/name of the input value */
  sourceName?: string;
}

export interface PassKTask {
  /** inference model configuration */
  reasoner?: Annotator;
  /** number of inferences */
  inferenceRound?: number;
  /** Evaluator configuration */
  judge?: Annotator;
  /** correct threshold */
  positiveThreshold?: number;
}

export interface QualityScoreJob {
  /** Unique ID, not passed on when created */
  id?: string;
  /** appID, not passed when created */
  appID?: number;
  /** Space ID, not passed when created */
  spaceID?: string;
  /** Dataset ID, not passed on when created */
  datasetID?: string;
  /** Version number, not passed when created */
  version?: string;
  /** Job ID, not passed on when created */
  jobID?: string;
  /** Mission name, don't pass it on */
  name?: string;
  /** Task status: active, inactive */
  status?: string;
  /** Tagged task type: passk */
  category?: string;
  /** passKTask task content */
  passKTask?: PassKTask;
  /** Whether to automatically calculate new data */
  autoCalculateNewData?: boolean;
  /** general information */
  createdAt?: string;
  createdBy?: string;
  updatedAt?: string;
  updatedBy?: string;
}

export interface QualityScoreJobInstance {
  /** Instance unique id */
  id?: string;
  /** Task ID */
  jobID?: string;
  /** total number of articles */
  total?: number;
  /** number of successes */
  successCnt?: number;
  /** number of failures */
  failedCnt?: number;
  /** task status */
  status?: string;
}

export interface RuleAnnotator {
  /** rule type */
  category?: RuleAnnotatorCategory;
  /** rule content */
  content?: string;
  /** input mapping */
  inputMappings?: Array<InputMapping>;
  /** output mapping */
  outputMappings?: Array<OutputMapping>;
  /** Allow unconfigured label options */
  allowUndefinedTagValues?: boolean;
  /** Marking null values only */
  onlyForEmpty?: boolean;
  /** Marking failures only */
  onlyForFailed?: boolean;
}

export interface SearchConfig {
  /** Dataset ID */
  datasetID?: string;
  /** Search task name */
  jobName?: string;
  /** Search task ID */
  jobID?: string;
  /** Search creator */
  createdBy?: Array<string>;
}
/* eslint-enable */
