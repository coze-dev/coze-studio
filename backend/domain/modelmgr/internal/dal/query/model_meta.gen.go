// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"code.byted.org/flow/opencoze/backend/domain/modelmgr/internal/dal/model"
)

func newModelMeta(db *gorm.DB, opts ...gen.DOOption) modelMeta {
	_modelMeta := modelMeta{}

	_modelMeta.modelMetaDo.UseDB(db, opts...)
	_modelMeta.modelMetaDo.UseModel(&model.ModelMeta{})

	tableName := _modelMeta.modelMetaDo.TableName()
	_modelMeta.ALL = field.NewAsterisk(tableName)
	_modelMeta.ID = field.NewInt64(tableName, "id")
	_modelMeta.ModelName = field.NewString(tableName, "model_name")
	_modelMeta.Protocol = field.NewString(tableName, "protocol")
	_modelMeta.IconURI = field.NewString(tableName, "icon_uri")
	_modelMeta.Capability = field.NewField(tableName, "capability")
	_modelMeta.ConnConfig = field.NewField(tableName, "conn_config")
	_modelMeta.Status = field.NewField(tableName, "status")
	_modelMeta.Description = field.NewString(tableName, "description")
	_modelMeta.CreatedAt = field.NewInt64(tableName, "created_at")
	_modelMeta.UpdatedAt = field.NewInt64(tableName, "updated_at")
	_modelMeta.DeletedAt = field.NewField(tableName, "deleted_at")
	_modelMeta.IconURL = field.NewString(tableName, "icon_url")

	_modelMeta.fillFieldMap()

	return _modelMeta
}

// modelMeta 模型元信息
type modelMeta struct {
	modelMetaDo

	ALL         field.Asterisk
	ID          field.Int64  // 主键ID
	ModelName   field.String // 模型名称
	Protocol    field.String // 模型协议
	IconURI     field.String // Icon URI
	Capability  field.Field  // 模型能力
	ConnConfig  field.Field  // 模型连接配置
	Status      field.Field  // 模型状态
	Description field.String // 模型描述
	CreatedAt   field.Int64  // Create Time in Milliseconds
	UpdatedAt   field.Int64  // Update Time in Milliseconds
	DeletedAt   field.Field  // Delete Time in Milliseconds
	IconURL     field.String // Icon URL

	fieldMap map[string]field.Expr
}

func (m modelMeta) Table(newTableName string) *modelMeta {
	m.modelMetaDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m modelMeta) As(alias string) *modelMeta {
	m.modelMetaDo.DO = *(m.modelMetaDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *modelMeta) updateTableName(table string) *modelMeta {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt64(table, "id")
	m.ModelName = field.NewString(table, "model_name")
	m.Protocol = field.NewString(table, "protocol")
	m.IconURI = field.NewString(table, "icon_uri")
	m.Capability = field.NewField(table, "capability")
	m.ConnConfig = field.NewField(table, "conn_config")
	m.Status = field.NewField(table, "status")
	m.Description = field.NewString(table, "description")
	m.CreatedAt = field.NewInt64(table, "created_at")
	m.UpdatedAt = field.NewInt64(table, "updated_at")
	m.DeletedAt = field.NewField(table, "deleted_at")
	m.IconURL = field.NewString(table, "icon_url")

	m.fillFieldMap()

	return m
}

func (m *modelMeta) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *modelMeta) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 12)
	m.fieldMap["id"] = m.ID
	m.fieldMap["model_name"] = m.ModelName
	m.fieldMap["protocol"] = m.Protocol
	m.fieldMap["icon_uri"] = m.IconURI
	m.fieldMap["capability"] = m.Capability
	m.fieldMap["conn_config"] = m.ConnConfig
	m.fieldMap["status"] = m.Status
	m.fieldMap["description"] = m.Description
	m.fieldMap["created_at"] = m.CreatedAt
	m.fieldMap["updated_at"] = m.UpdatedAt
	m.fieldMap["deleted_at"] = m.DeletedAt
	m.fieldMap["icon_url"] = m.IconURL
}

func (m modelMeta) clone(db *gorm.DB) modelMeta {
	m.modelMetaDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m modelMeta) replaceDB(db *gorm.DB) modelMeta {
	m.modelMetaDo.ReplaceDB(db)
	return m
}

type modelMetaDo struct{ gen.DO }

type IModelMetaDo interface {
	gen.SubQuery
	Debug() IModelMetaDo
	WithContext(ctx context.Context) IModelMetaDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IModelMetaDo
	WriteDB() IModelMetaDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IModelMetaDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IModelMetaDo
	Not(conds ...gen.Condition) IModelMetaDo
	Or(conds ...gen.Condition) IModelMetaDo
	Select(conds ...field.Expr) IModelMetaDo
	Where(conds ...gen.Condition) IModelMetaDo
	Order(conds ...field.Expr) IModelMetaDo
	Distinct(cols ...field.Expr) IModelMetaDo
	Omit(cols ...field.Expr) IModelMetaDo
	Join(table schema.Tabler, on ...field.Expr) IModelMetaDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IModelMetaDo
	RightJoin(table schema.Tabler, on ...field.Expr) IModelMetaDo
	Group(cols ...field.Expr) IModelMetaDo
	Having(conds ...gen.Condition) IModelMetaDo
	Limit(limit int) IModelMetaDo
	Offset(offset int) IModelMetaDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IModelMetaDo
	Unscoped() IModelMetaDo
	Create(values ...*model.ModelMeta) error
	CreateInBatches(values []*model.ModelMeta, batchSize int) error
	Save(values ...*model.ModelMeta) error
	First() (*model.ModelMeta, error)
	Take() (*model.ModelMeta, error)
	Last() (*model.ModelMeta, error)
	Find() ([]*model.ModelMeta, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ModelMeta, err error)
	FindInBatches(result *[]*model.ModelMeta, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ModelMeta) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IModelMetaDo
	Assign(attrs ...field.AssignExpr) IModelMetaDo
	Joins(fields ...field.RelationField) IModelMetaDo
	Preload(fields ...field.RelationField) IModelMetaDo
	FirstOrInit() (*model.ModelMeta, error)
	FirstOrCreate() (*model.ModelMeta, error)
	FindByPage(offset int, limit int) (result []*model.ModelMeta, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IModelMetaDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m modelMetaDo) Debug() IModelMetaDo {
	return m.withDO(m.DO.Debug())
}

func (m modelMetaDo) WithContext(ctx context.Context) IModelMetaDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m modelMetaDo) ReadDB() IModelMetaDo {
	return m.Clauses(dbresolver.Read)
}

func (m modelMetaDo) WriteDB() IModelMetaDo {
	return m.Clauses(dbresolver.Write)
}

func (m modelMetaDo) Session(config *gorm.Session) IModelMetaDo {
	return m.withDO(m.DO.Session(config))
}

func (m modelMetaDo) Clauses(conds ...clause.Expression) IModelMetaDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m modelMetaDo) Returning(value interface{}, columns ...string) IModelMetaDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m modelMetaDo) Not(conds ...gen.Condition) IModelMetaDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m modelMetaDo) Or(conds ...gen.Condition) IModelMetaDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m modelMetaDo) Select(conds ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m modelMetaDo) Where(conds ...gen.Condition) IModelMetaDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m modelMetaDo) Order(conds ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m modelMetaDo) Distinct(cols ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m modelMetaDo) Omit(cols ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m modelMetaDo) Join(table schema.Tabler, on ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m modelMetaDo) LeftJoin(table schema.Tabler, on ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m modelMetaDo) RightJoin(table schema.Tabler, on ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m modelMetaDo) Group(cols ...field.Expr) IModelMetaDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m modelMetaDo) Having(conds ...gen.Condition) IModelMetaDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m modelMetaDo) Limit(limit int) IModelMetaDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m modelMetaDo) Offset(offset int) IModelMetaDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m modelMetaDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IModelMetaDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m modelMetaDo) Unscoped() IModelMetaDo {
	return m.withDO(m.DO.Unscoped())
}

func (m modelMetaDo) Create(values ...*model.ModelMeta) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m modelMetaDo) CreateInBatches(values []*model.ModelMeta, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m modelMetaDo) Save(values ...*model.ModelMeta) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m modelMetaDo) First() (*model.ModelMeta, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelMeta), nil
	}
}

func (m modelMetaDo) Take() (*model.ModelMeta, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelMeta), nil
	}
}

func (m modelMetaDo) Last() (*model.ModelMeta, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelMeta), nil
	}
}

func (m modelMetaDo) Find() ([]*model.ModelMeta, error) {
	result, err := m.DO.Find()
	return result.([]*model.ModelMeta), err
}

func (m modelMetaDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ModelMeta, err error) {
	buf := make([]*model.ModelMeta, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m modelMetaDo) FindInBatches(result *[]*model.ModelMeta, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m modelMetaDo) Attrs(attrs ...field.AssignExpr) IModelMetaDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m modelMetaDo) Assign(attrs ...field.AssignExpr) IModelMetaDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m modelMetaDo) Joins(fields ...field.RelationField) IModelMetaDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m modelMetaDo) Preload(fields ...field.RelationField) IModelMetaDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m modelMetaDo) FirstOrInit() (*model.ModelMeta, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelMeta), nil
	}
}

func (m modelMetaDo) FirstOrCreate() (*model.ModelMeta, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelMeta), nil
	}
}

func (m modelMetaDo) FindByPage(offset int, limit int) (result []*model.ModelMeta, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m modelMetaDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m modelMetaDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m modelMetaDo) Delete(models ...*model.ModelMeta) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *modelMetaDo) withDO(do gen.Dao) *modelMetaDo {
	m.DO = *do.(*gen.DO)
	return m
}
