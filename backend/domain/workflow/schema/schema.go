package schema

import (
	"context"
	"fmt"

	"github.com/cloudwego/eino/compose"

	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/batch"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/httprequester"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/selector"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/textprocessor"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/variableaggregator"
)

type NodeSchema struct {
	Type NodeType `json:"type"`

	// Configs are node specific configurations with pre-defined config key and config value.
	// Will not participate in request-time field mapping, nor as node's static values.
	// In a word, these Configs are INTERNAL to node's implementation, the workflow layer is not aware of them.
	Configs any `json:"configs"`

	// Inputs are node specific input fields with pre-defined field name, or user defined input fields with dynamic field name.
	// Can have either ref or literal as value.
	// Will participate in request-time field mapping, or as node's static values.
	// In a words, these Inputs are managed at workflow layer:
	// the workflow engine is responsible to infer field mappings and static values from these, and add dependencies accordingly.
	Inputs []*nodes.InputField `json:"inputs"`

	// Outputs are node specific output fields with pre-defined field name, or user defined output fields with dynamic field name.
	// Usually they do not have 'Source' information, as they are generated by node itself, not referenced from other nodes or set as static value.
	// In some cases, they can have 'Source' information, because they refer to outputs of inner workflow's nodes (such as Batch node's output),
	// or they just use static values (such as part of End node's output).
	// The workflow layer is not aware of these Outputs.
	Outputs map[string]*LayeredFieldInfo `json:"outputs"`

	Lambda *compose.Lambda // not serializable, used for internal test.
}

type LayeredFieldInfo struct {
	Info   *nodes.FieldInfo             `json:"info"`
	Object map[string]*LayeredFieldInfo `json:"object"`
}

type NodeType string

const (
	NodeTypeLLM                NodeType = "LLM"
	NodeTypeSelector           NodeType = "Selector"
	NodeTypeBatch              NodeType = "Batch"
	NodeTypeVariableAggregator NodeType = "VariableAggregator"
	NodeTypeTextProcessor      NodeType = "TextProcessor"
	NodeTypeHTTPRequester      NodeType = "HTTPRequester"

	NodeTypeLambda NodeType = "Lambda"
)

type Node struct {
	Lambda *compose.Lambda
	Graph  compose.AnyGraph
}

func (s *NodeSchema) New(ctx context.Context, inner compose.Runnable[map[string]any, map[string]any]) (*Node, error) {
	switch s.Type {
	case NodeTypeLambda:
		if s.Lambda == nil {
			return nil, fmt.Errorf("lambda is not defined for NodeTypeLambda")
		}

		return &Node{Lambda: s.Lambda}, nil
	case NodeTypeSelector:
		conf, err := s.ToSelectorConfig()
		if err != nil {
			return nil, err
		}

		sl, err := selector.NewSelector(ctx, conf)
		if err != nil {
			return nil, err
		}

		i := func(ctx context.Context, in map[string]any) (int, error) {
			newIn, err := s.SelectorInputConverter(in)
			if err != nil {
				return -1, err
			}

			return sl.Select(ctx, newIn)
		}

		return &Node{Lambda: compose.InvokableLambda(i)}, nil
	case NodeTypeBatch:
		if inner == nil {
			return nil, fmt.Errorf("inner workflow must not be nil when creating batch node")
		}

		conf, err := s.ToBatchConfig(inner)
		if err != nil {
			return nil, err
		}

		b, err := batch.NewBatch(ctx, conf)
		if err != nil {
			return nil, err
		}

		return &Node{Lambda: compose.InvokableLambda(b.Execute)}, nil
	case NodeTypeVariableAggregator:
		conf, err := s.ToVariableAggregatorConfig()
		if err != nil {
			return nil, err
		}

		va, err := variableaggregator.NewVariableAggregator(ctx, conf)
		if err != nil {
			return nil, err
		}

		i := func(ctx context.Context, in map[string]any) (map[string]any, error) {
			newIn, err := s.VariableAggregatorInputConverter(in)
			if err != nil {
				return nil, err
			}

			return va.Invoke(ctx, newIn)
		}

		return &Node{Lambda: compose.InvokableLambda(i)}, nil
	case NodeTypeTextProcessor:
		conf, err := s.ToTextProcessorConfig()
		if err != nil {
			return nil, err
		}

		tp, err := textprocessor.NewTextProcessor(ctx, conf)
		if err != nil {
			return nil, err
		}

		return &Node{Lambda: compose.InvokableLambda(tp.Invoke)}, nil
	case NodeTypeHTTPRequester:
		conf, err := s.ToHTTPRequesterConfig()
		if err != nil {
			return nil, err
		}

		hr, err := httprequester.NewHTTPRequester(ctx, conf)
		if err != nil {
			return nil, err
		}

		return &Node{Lambda: compose.InvokableLambda(hr.Invoke)}, nil
	default:
		panic("not implemented")
	}
}
