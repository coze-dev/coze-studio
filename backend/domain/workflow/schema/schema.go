package schema

import (
	"context"
	"fmt"

	"github.com/cloudwego/eino/compose"
	"github.com/cloudwego/eino/schema"

	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/batch"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/httprequester"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/loop"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/selector"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/textprocessor"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/variableaggregator"
	"code.byted.org/flow/opencoze/backend/domain/workflow/nodes/variableassigner"
	"code.byted.org/flow/opencoze/backend/domain/workflow/variables"
)

type NodeSchema struct {
	Type NodeType `json:"type"`

	// Configs are node specific configurations with pre-defined config key and config value.
	// Will not participate in request-time field mapping, nor as node's static values.
	// In a word, these Configs are INTERNAL to node's implementation, the workflow layer is not aware of them.
	Configs any `json:"configs"`

	// Inputs are node specific input fields with pre-defined field name, or user defined input fields with dynamic field name.
	// Can have either ref or literal as value.
	// Will participate in request-time field mapping, or as node's static values.
	// In a words, these Inputs are managed at workflow layer:
	// the workflow engine is responsible to infer field mappings and static values from these, and add dependencies accordingly.
	Inputs []*nodes.InputField `json:"inputs"`

	// Outputs are node specific output fields with pre-defined field name, or user defined output fields with dynamic field name.
	// Usually they do not have 'Source' information, as they are generated by node itself, not referenced from other nodes or set as static value.
	// In some cases, they can have 'Source' information, because they refer to outputs of inner workflow's nodes (such as Batch node's output),
	// or they just use static values (such as part of End node's output).
	// The workflow layer is not aware of these Outputs.
	Outputs map[string]*LayeredFieldInfo `json:"outputs"`

	Lambda *compose.Lambda // not serializable, used for internal test.
}

type LayeredFieldInfo struct {
	Info   *nodes.FieldInfo             `json:"info"`
	Object map[string]*LayeredFieldInfo `json:"object"`
}

type NodeType string

const (
	NodeTypeLLM                NodeType = "LLM"
	NodeTypeSelector           NodeType = "Selector"
	NodeTypeBatch              NodeType = "Batch"
	NodeTypeVariableAggregator NodeType = "VariableAggregator"
	NodeTypeTextProcessor      NodeType = "TextProcessor"
	NodeTypeHTTPRequester      NodeType = "HTTPRequester"

	NodeTypeLoop             NodeType = "Loop"
	NodeTypeContinue         NodeType = "Continue"
	NodeTypeBreak            NodeType = "Break"
	NodeTypeVariableAssigner NodeType = "VariableAssigner"

	NodeTypeLambda NodeType = "Lambda"
)

type Node struct {
	Lambda *compose.Lambda
	Graph  compose.AnyGraph
}

func (s *NodeSchema) New(ctx context.Context, inner compose.Runnable[map[string]any, map[string]any]) (*Node, error) {
	switch s.Type {
	case NodeTypeLambda:
		if s.Lambda == nil {
			return nil, fmt.Errorf("lambda is not defined for NodeTypeLambda")
		}

		return &Node{Lambda: s.Lambda}, nil
	case NodeTypeSelector:
		conf, err := s.ToSelectorConfig()
		if err != nil {
			return nil, err
		}

		sl, err := selector.NewSelector(ctx, conf)
		if err != nil {
			return nil, err
		}

		i := func(ctx context.Context, in map[string]any) (int, error) {
			newIn, err := s.SelectorInputConverter(in)
			if err != nil {
				return -1, err
			}

			return sl.Select(ctx, newIn)
		}

		return &Node{Lambda: compose.InvokableLambda(i)}, nil
	case NodeTypeBatch:
		if inner == nil {
			return nil, fmt.Errorf("inner workflow must not be nil when creating batch node")
		}

		conf, err := s.ToBatchConfig(inner)
		if err != nil {
			return nil, err
		}

		b, err := batch.NewBatch(ctx, conf)
		if err != nil {
			return nil, err
		}

		return &Node{Lambda: compose.InvokableLambda(b.Execute)}, nil
	case NodeTypeVariableAggregator:
		conf, err := s.ToVariableAggregatorConfig()
		if err != nil {
			return nil, err
		}

		va, err := variableaggregator.NewVariableAggregator(ctx, conf)
		if err != nil {
			return nil, err
		}

		i := func(ctx context.Context, in map[string]any) (map[string]any, error) {
			newIn, err := s.VariableAggregatorInputConverter(in)
			if err != nil {
				return nil, err
			}

			return va.Invoke(ctx, newIn)
		}

		return &Node{Lambda: compose.InvokableLambda(i)}, nil
	case NodeTypeTextProcessor:
		conf, err := s.ToTextProcessorConfig()
		if err != nil {
			return nil, err
		}

		tp, err := textprocessor.NewTextProcessor(ctx, conf)
		if err != nil {
			return nil, err
		}

		return &Node{Lambda: compose.InvokableLambda(tp.Invoke)}, nil
	case NodeTypeHTTPRequester:
		conf, err := s.ToHTTPRequesterConfig()
		if err != nil {
			return nil, err
		}

		hr, err := httprequester.NewHTTPRequester(ctx, conf)
		if err != nil {
			return nil, err
		}

		return &Node{Lambda: compose.InvokableLambda(hr.Invoke)}, nil
	case NodeTypeContinue:
		i := func(ctx context.Context, in map[string]any, opts ...any) (map[string]any, error) {
			return map[string]any{}, nil
		}
		c := func(ctx context.Context, in *schema.StreamReader[map[string]any], opts ...any) (map[string]any, error) {
			in.Close()
			return map[string]any{}, nil
		}
		l, err := compose.AnyLambda(i, nil, c, nil)
		if err != nil {
			return nil, err
		}
		return &Node{Lambda: l}, nil
	case NodeTypeBreak:
		b, err := loop.NewBreak(ctx, &variables.ParentIntermediateStore{})
		if err != nil {
			return nil, err
		}
		i := func(ctx context.Context, in map[string]any, opts ...any) (map[string]any, error) {
			if err := b.DoBreak(ctx); err != nil {
				return nil, err
			}
			return map[string]any{}, nil
		}
		c := func(ctx context.Context, in *schema.StreamReader[map[string]any], opts ...any) (map[string]any, error) {
			in.Close()
			if err := b.DoBreak(ctx); err != nil {
				return nil, err
			}
			return map[string]any{}, nil
		}
		l, err := compose.AnyLambda(i, nil, c, nil)
		if err != nil {
			return nil, err
		}
		return &Node{Lambda: l}, nil
	case NodeTypeVariableAssigner:
		handler := &variables.VariableHandler{
			UserVarStore:               nil, // TODO: inject this
			SystemVarStore:             nil, // TODO: inject this
			AppVarStore:                nil, // TODO: inject this
			ParentIntermediateVarStore: &variables.ParentIntermediateStore{},
		}

		conf, err := s.ToVariableAssignerConfig(handler)
		if err != nil {
			return nil, err
		}
		va, err := variableassigner.NewVariableAssigner(ctx, conf)
		if err != nil {
			return nil, err
		}
		i := func(ctx context.Context, in map[string]any) (map[string]any, error) {
			err := va.Assign(ctx, in)
			if err != nil {
				return nil, err
			}

			return map[string]any{}, nil
		}
		return &Node{Lambda: compose.InvokableLambda(i)}, nil
	case NodeTypeLoop:
		conf, err := s.ToLoopConfig(inner)
		if err != nil {
			return nil, err
		}
		l, err := loop.NewLoop(ctx, conf)
		if err != nil {
			return nil, err
		}
		return &Node{Lambda: compose.InvokableLambda(l.Execute)}, nil
	default:
		panic("not implemented")
	}
}

func (s *NodeSchema) GenInnerState() compose.GenLocalState[*variables.VariableHandler] {
	switch s.Type {
	case NodeTypeLoop:
		return variables.GenStateFn(&variables.ParentIntermediateStore{}, nil, nil, nil)
	default:
		return nil
	}
}

func (s *NodeSchema) StatePreHandler() compose.StatePreHandler[map[string]any, *variables.VariableHandler] {
	// checkout the node's inputs, if it has any variable, use the state's variableHandler to get the variables and set them to the input
	var vars []*nodes.InputField
	for _, input := range s.Inputs {
		if input.Info.Source.Ref != nil && input.Info.Source.Ref.VariableType != nil {
			vars = append(vars, input)
		}
	}

	if len(vars) == 0 {
		return nil
	}

	return func(ctx context.Context, in map[string]any, state *variables.VariableHandler) (map[string]any, error) {
		out := make(map[string]any)
		for k, v := range in {
			out[k] = v
		}

		for _, input := range vars {
			v, err := state.Get(ctx, *input.Info.Source.Ref.VariableType, input.Info.Source.Ref.FromPath)
			if err != nil {
				return nil, err
			}
			nodes.SetMapValue(out, input.Path, v)
		}

		return out, nil
	}
}
