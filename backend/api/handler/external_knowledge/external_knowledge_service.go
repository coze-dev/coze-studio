// Code generated by hertz generator.

package external_knowledge

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"

	external_knowledge "github.com/coze-dev/coze-studio/backend/api/model/external_knowledge"
	"github.com/coze-dev/coze-studio/backend/application/base/ctxutil"
	externalKnowledgeApp "github.com/coze-dev/coze-studio/backend/application/external_knowledge"
	userApp "github.com/coze-dev/coze-studio/backend/application/user"
	"github.com/coze-dev/coze-studio/backend/pkg/lang/ptr"
	"github.com/coze-dev/coze-studio/backend/pkg/logs"
)

// CreateBinding .
// @router /api/external-knowledge/binding/create [POST]
func CreateBinding(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.CreateBindingRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.CreateBindingResponse{
			Code: 401,
			Msg:  "Unauthorized",
			Data: &external_knowledge.ExternalKnowledgeBinding{},
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.CreateBinding(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetBindingList .
// @router /api/external-knowledge/binding/list [GET]
func GetBindingList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.GetBindingListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.GetBindingListResponse{
			Code:  401,
			Msg:   "Unauthorized",
			Data:  []*external_knowledge.ExternalKnowledgeBinding{},
			Total: 0,
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.GetBindingList(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// UpdateBinding .
// @router /api/external-knowledge/binding/:id [PUT]
func UpdateBinding(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.UpdateBindingRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.UpdateBindingResponse{
			Code: 401,
			Msg:  "Unauthorized",
			Data: &external_knowledge.ExternalKnowledgeBinding{},
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.UpdateBinding(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// DeleteBinding .
// @router /api/external-knowledge/binding/:id [DELETE]
func DeleteBinding(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.DeleteBindingRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.DeleteBindingResponse{
			Code: 401,
			Msg:  "Unauthorized",
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.DeleteBinding(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// ValidateBindingKey .
// @router /api/external-knowledge/binding/validate [POST]
func ValidateBindingKey(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.ValidateBindingKeyRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Check if user is authenticated (optional for validation)
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.ValidateBindingKeyResponse{
			Code:    401,
			Msg:     "Unauthorized",
			IsValid: false,
		})
		return
	}

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.ValidateBindingKey(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetRAGFlowDatasets .
// @router /api/external-knowledge/ragflow/datasets [GET]
func GetRAGFlowDatasets(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.GetRAGFlowDatasetsRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context for authentication
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusOK, &external_knowledge.GetRAGFlowDatasetsResponse{
			Code: 401,
			Msg:  "Unauthorized",
			Data: []*external_knowledge.RAGFlowDataset{},
		})
		return
	}

	userID := ptr.From(userIDPtr)

	// 调用RAGFlow API，使用后端保存的session key
	resp, err := callRAGFlowDatasetsAPI(ctx, userID)
	if err != nil {
		c.JSON(consts.StatusOK, &external_knowledge.GetRAGFlowDatasetsResponse{
			Code: 500,
			Msg:  err.Error(),
			Data: []*external_knowledge.RAGFlowDataset{},
		})
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// CreateRAGFlowDataset proxies dataset creation to RAGFlow.
func CreateRAGFlowDataset(ctx context.Context, c *app.RequestContext) {
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, map[string]interface{}{
			"code":    401,
			"message": "Unauthorized",
		})
		return
	}

	sessionKey, err := getUserSessionKey(ctx, ptr.From(userIDPtr))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		})
		return
	}

	payload := append([]byte(nil), c.Request.Body()...)
	if len(payload) == 0 {
		payload = []byte("{}")
	}

	referer := fmt.Sprintf("%s/dataset", ragflowWebBase())
	statusCode, respBody, err := proxyRAGFlowJSON(ctx, sessionKey, http.MethodPost, "/v1/kb/create", payload, referer)
	if err != nil {
		logs.CtxErrorf(ctx, "[ExternalKnowledge] create dataset failed: %v", err)
		c.JSON(consts.StatusInternalServerError, map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		})
		return
	}

	c.Data(statusCode, "application/json", respBody)
}

// UpdateRAGFlowDataset proxies dataset update to RAGFlow.
func UpdateRAGFlowDataset(ctx context.Context, c *app.RequestContext) {
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, map[string]interface{}{
			"code":    401,
			"message": "Unauthorized",
		})
		return
	}

	sessionKey, err := getUserSessionKey(ctx, ptr.From(userIDPtr))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		})
		return
	}

	payload := append([]byte(nil), c.Request.Body()...)
	if len(payload) == 0 {
		payload = []byte("{}")
	}

	referer := fmt.Sprintf("%s/dataset", ragflowWebBase())
	if kbID := extractKbIDFromPayload(payload); kbID != "" {
		referer = fmt.Sprintf("%s/dataset/dataset/%s", ragflowWebBase(), kbID)
	}

	statusCode, respBody, err := proxyRAGFlowJSON(ctx, sessionKey, http.MethodPost, "/v1/kb/update", payload, referer)
	if err != nil {
		logs.CtxErrorf(ctx, "[ExternalKnowledge] update dataset failed: %v", err)
		c.JSON(consts.StatusInternalServerError, map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		})
		return
	}

	c.Data(statusCode, "application/json", respBody)
}

// DeleteRAGFlowDataset proxies dataset removal to RAGFlow.
func DeleteRAGFlowDataset(ctx context.Context, c *app.RequestContext) {
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, map[string]interface{}{
			"code":    401,
			"message": "Unauthorized",
		})
		return
	}

	sessionKey, err := getUserSessionKey(ctx, ptr.From(userIDPtr))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		})
		return
	}

	payload := append([]byte(nil), c.Request.Body()...)
	if len(payload) == 0 {
		payload = []byte("{}")
	}

	referer := fmt.Sprintf("%s/dataset", ragflowWebBase())
	if kbID := extractKbIDFromPayload(payload); kbID != "" {
		referer = fmt.Sprintf("%s/dataset/dataset/%s", ragflowWebBase(), kbID)
	}

	statusCode, respBody, err := proxyRAGFlowJSON(ctx, sessionKey, http.MethodPost, "/v1/kb/rm", payload, referer)
	if err != nil {
		logs.CtxErrorf(ctx, "[ExternalKnowledge] delete dataset failed: %v", err)
		c.JSON(consts.StatusInternalServerError, map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		})
		return
	}

	c.Data(statusCode, "application/json", respBody)
}

// GetRAGFlowSessionKey returns current user's session key for RAGFlow link stitching.
func GetRAGFlowSessionKey(ctx context.Context, c *app.RequestContext) {
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, map[string]interface{}{
			"code":    401,
			"message": "Unauthorized",
		})
		return
	}

	sessionKey, err := getUserSessionKey(ctx, ptr.From(userIDPtr))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, map[string]interface{}{
			"code":    500,
			"message": err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, map[string]interface{}{
		"code": 0,
		"data": map[string]string{
			"session_key": sessionKey,
		},
	})
}

// callRAGFlowDatasetsAPI 调用RAGFlow的知识库列表API，使用用户在系统中保存的session key
func callRAGFlowDatasetsAPI(ctx context.Context, userID int64) (*external_knowledge.GetRAGFlowDatasetsResponse, error) {
	sessionKey, err := getUserSessionKey(ctx, userID)
	if err != nil {
		return nil, err
	}

	referer := fmt.Sprintf("%s/dataset", ragflowWebBase())
	statusCode, respBody, err := proxyRAGFlowJSON(ctx, sessionKey, http.MethodPost, "/v1/kb/list", []byte("{}"), referer)
	if err != nil {
		return nil, err
	}

	if statusCode != http.StatusOK {
		logs.CtxWarnf(ctx, "[ExternalKnowledge] RAGFlow list non-200 status, userID=%d, status=%d", userID, statusCode)
	}

	// Parse RAGFlow response
	var ragflowResp struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Data    struct {
			Kbs []struct {
				ID          string `json:"id"`
				Name        string `json:"name"`
				Nickname    string `json:"nickname"`
				Description string `json:"description"`
				Avatar      string `json:"avatar"`
				DocNum      int    `json:"doc_num"`
				ChunkNum    int    `json:"chunk_num"`
				TokenNum    int    `json:"token_num"`
				Language    string `json:"language"`
				EmbdID      string `json:"embd_id"`
				UpdateTime  int64  `json:"update_time"`
			} `json:"kbs"`
			Total int `json:"total"`
		} `json:"data"`
	}

	if err := json.Unmarshal(respBody, &ragflowResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	// Convert RAGFlow response to our format
	datasets := make([]*external_knowledge.RAGFlowDataset, len(ragflowResp.Data.Kbs))
	for i, kb := range ragflowResp.Data.Kbs {
		description := kb.Description
		avatar := kb.Avatar
		datasets[i] = &external_knowledge.RAGFlowDataset{
			ID:             kb.ID,
			Name:           kb.Name,
			Description:    &description,
			Avatar:         &avatar,
			DocumentCount:  int32(kb.DocNum),
			ChunkCount:     int32(kb.ChunkNum),
			TokenNum:       int64(kb.TokenNum),
			Language:       kb.Language,
			EmbeddingModel: kb.EmbdID,
			CreateDate:     "", // RAGFlow doesn't return create_date
			CreateTime:     0,  // RAGFlow doesn't return create_time
			UpdateDate:     "", // RAGFlow doesn't return update_date
			UpdateTime:     kb.UpdateTime,
			Status:         1, // Assume all returned KBs are active
		}
	}

	return &external_knowledge.GetRAGFlowDatasetsResponse{
		Code: int32(ragflowResp.Code),
		Msg:  ragflowResp.Message,
		Data: datasets,
	}, nil
}

func getUserSessionKey(ctx context.Context, userID int64) (string, error) {
	userInfo, err := userApp.UserApplicationSVC.DomainSVC.GetUserInfo(ctx, userID)
	if err != nil {
		logs.CtxErrorf(ctx, "[ExternalKnowledge] GetUserInfo failed, userID=%d, err=%v", userID, err)
		return "", fmt.Errorf("failed to get user info: %w", err)
	}

	if userInfo == nil || userInfo.SessionKey == "" {
		return "", fmt.Errorf("user session key is empty")
	}

	return userInfo.SessionKey, nil
}

func proxyRAGFlowJSON(ctx context.Context, sessionKey string, method, path string, payload []byte, referer string) (int, []byte, error) {
	if payload == nil {
		payload = []byte("{}")
	}

	req, err := http.NewRequestWithContext(ctx, method, fmt.Sprintf("%s%s", ragflowAPIBase(), path), bytes.NewReader(payload))
	if err != nil {
		return 0, nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Accept", "application/json")
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	req.Header.Set("Connection", "keep-alive")
	webBase := ragflowWebBase()
	req.Header.Set("Origin", webBase)
	if referer == "" {
		referer = webBase
	}
	req.Header.Set("Referer", referer)
	req.Header.Set("Cookie", fmt.Sprintf("session_key=%s", sessionKey))

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return 0, nil, fmt.Errorf("failed to call RAGFlow API: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return resp.StatusCode, nil, fmt.Errorf("failed to read response: %w", err)
	}

	return resp.StatusCode, body, nil
}

func ragflowAPIBase() string {
	if api := os.Getenv("RAGFLOW_API_URL"); api != "" {
		return api
	}
	return "https://ynetflow-agent.finmall.com"
}

func ragflowWebBase() string {
	if web := os.Getenv("RAGFLOW_WEB_URL"); web != "" {
		return web
	}
	return "https://ynetflow-agent.finmall.com"
}

func extractKbIDFromPayload(payload []byte) string {
	var req struct {
		KbID string `json:"kb_id"`
	}
	if err := json.Unmarshal(payload, &req); err != nil {
		return ""
	}
	return req.KbID
}

// Retrieval .
// @router /api/external-knowledge/retrieval [POST]
func Retrieval(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.RetrievalRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context (optional for retrieval)
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.RetrievalResponse{
			Code: 401,
			Msg:  "Unauthorized",
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	// Call application service to perform retrieval
	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.Retrieval(ctx, userID, &req)
	if err != nil {
		c.JSON(consts.StatusOK, &external_knowledge.RetrievalResponse{
			Code: 500,
			Msg:  err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, resp)
}
