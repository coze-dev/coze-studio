// Code generated by hertz generator.

package external_knowledge

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"

	external_knowledge "github.com/coze-dev/coze-studio/backend/api/model/external_knowledge"
	"github.com/coze-dev/coze-studio/backend/application/base/ctxutil"
	externalKnowledgeApp "github.com/coze-dev/coze-studio/backend/application/external_knowledge"
	"github.com/coze-dev/coze-studio/backend/pkg/lang/ptr"
)

// CreateBinding .
// @router /api/external-knowledge/binding/create [POST]
func CreateBinding(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.CreateBindingRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.CreateBindingResponse{
			Code: 401,
			Msg:  "Unauthorized",
			Data: &external_knowledge.ExternalKnowledgeBinding{},
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.CreateBinding(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetBindingList .
// @router /api/external-knowledge/binding/list [GET]
func GetBindingList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.GetBindingListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.GetBindingListResponse{
			Code:  401,
			Msg:   "Unauthorized",
			Data:  []*external_knowledge.ExternalKnowledgeBinding{},
			Total: 0,
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.GetBindingList(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// UpdateBinding .
// @router /api/external-knowledge/binding/:id [PUT]
func UpdateBinding(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.UpdateBindingRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.UpdateBindingResponse{
			Code: 401,
			Msg:  "Unauthorized",
			Data: &external_knowledge.ExternalKnowledgeBinding{},
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.UpdateBinding(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// DeleteBinding .
// @router /api/external-knowledge/binding/:id [DELETE]
func DeleteBinding(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.DeleteBindingRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.DeleteBindingResponse{
			Code: 401,
			Msg:  "Unauthorized",
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.DeleteBinding(ctx, userID, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// ValidateBindingKey .
// @router /api/external-knowledge/binding/validate [POST]
func ValidateBindingKey(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.ValidateBindingKeyRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Check if user is authenticated (optional for validation)
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.ValidateBindingKeyResponse{
			Code:    401,
			Msg:     "Unauthorized",
			IsValid: false,
		})
		return
	}

	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.ValidateBindingKey(ctx, &req)
	if err != nil {
		c.String(consts.StatusInternalServerError, err.Error())
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// GetRAGFlowDatasets .
// @router /api/external-knowledge/ragflow/datasets [GET]
func GetRAGFlowDatasets(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.GetRAGFlowDatasetsRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context for authentication
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusOK, &external_knowledge.GetRAGFlowDatasetsResponse{
			Code: 401,
			Msg:  "Unauthorized",
			Data: []*external_knowledge.RAGFlowDataset{},
		})
		return
	}

	// 直接调用RAGFlow API，使用用户的session cookie
	resp, err := callRAGFlowDatasetsAPI(ctx, c)
	if err != nil {
		c.JSON(consts.StatusOK, &external_knowledge.GetRAGFlowDatasetsResponse{
			Code: 500,
			Msg:  err.Error(),
			Data: []*external_knowledge.RAGFlowDataset{},
		})
		return
	}

	c.JSON(consts.StatusOK, resp)
}

// callRAGFlowDatasetsAPI 直接调用RAGFlow的知识库列表API
func callRAGFlowDatasetsAPI(ctx context.Context, c *app.RequestContext) (*external_knowledge.GetRAGFlowDatasetsResponse, error) {
	// Get RAGFlow API URL from environment
	ragflowAPIURL := os.Getenv("RAGFLOW_API_URL")
	if ragflowAPIURL == "" {
		ragflowAPIURL = "https://ynetflow-agent.finmall.com" // fallback to production URL
	}

	// Create HTTP request to RAGFlow API
	httpReq, err := http.NewRequestWithContext(ctx, "POST", fmt.Sprintf("%s/v1/kb/list", ragflowAPIURL), strings.NewReader("{}"))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers matching the frontend request
	httpReq.Header.Set("Accept", "application/json")
	httpReq.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	httpReq.Header.Set("Content-Type", "application/json;charset=UTF-8")
	httpReq.Header.Set("Connection", "keep-alive")
	// Use the same URL for Origin header
	ragflowWebURL := os.Getenv("RAGFLOW_WEB_URL")
	if ragflowWebURL == "" {
		ragflowWebURL = "https://ynetflow-agent.finmall.com"
	}
	httpReq.Header.Set("Origin", ragflowWebURL)

	// 传递用户的cookie
	cookieHeader := c.GetHeader("Cookie")
	if len(cookieHeader) > 0 {
		httpReq.Header.Set("Cookie", string(cookieHeader))
	}

	// Send request
	client := &http.Client{}
	resp, err := client.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("failed to call RAGFlow API: %w", err)
	}
	defer resp.Body.Close()

	// Parse RAGFlow response
	var ragflowResp struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Data    struct {
			Kbs   []struct {
				ID          string `json:"id"`
				Name        string `json:"name"`
				Nickname    string `json:"nickname"`
				Description string `json:"description"`
				Avatar      string `json:"avatar"`
				DocNum      int    `json:"doc_num"`
				ChunkNum    int    `json:"chunk_num"`
				TokenNum    int    `json:"token_num"`
				Language    string `json:"language"`
				EmbdID      string `json:"embd_id"`
				UpdateTime  int64  `json:"update_time"`
			} `json:"kbs"`
			Total int `json:"total"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&ragflowResp); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	// Convert RAGFlow response to our format
	datasets := make([]*external_knowledge.RAGFlowDataset, len(ragflowResp.Data.Kbs))
	for i, kb := range ragflowResp.Data.Kbs {
		datasets[i] = &external_knowledge.RAGFlowDataset{
			ID:               kb.ID,
			Name:             kb.Name,
			Description:      &kb.Description,
			Avatar:           &kb.Avatar,
			DocumentCount:    int32(kb.DocNum),
			ChunkCount:       int32(kb.ChunkNum),
			TokenNum:         int64(kb.TokenNum),
			Language:         kb.Language,
			EmbeddingModel:   kb.EmbdID,
			CreateDate:       "", // RAGFlow doesn't return create_date
			CreateTime:       0,  // RAGFlow doesn't return create_time
			UpdateDate:       "", // RAGFlow doesn't return update_date
			UpdateTime:       kb.UpdateTime,
			Status:           1, // Assume all returned KBs are active
		}
	}

	return &external_knowledge.GetRAGFlowDatasetsResponse{
		Code: int32(ragflowResp.Code),
		Msg:  ragflowResp.Message,
		Data: datasets,
	}, nil
}

// Retrieval .
// @router /api/external-knowledge/retrieval [POST]
func Retrieval(ctx context.Context, c *app.RequestContext) {
	var err error
	var req external_knowledge.RetrievalRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context (optional for retrieval)
	userIDPtr := ctxutil.GetUIDFromCtx(ctx)
	if userIDPtr == nil {
		c.JSON(consts.StatusUnauthorized, external_knowledge.RetrievalResponse{
			Code: 401,
			Msg:  "Unauthorized",
		})
		return
	}
	userID := strconv.FormatInt(ptr.From(userIDPtr), 10)

	// Call application service to perform retrieval
	resp, err := externalKnowledgeApp.ExternalKnowledgeApplicationSVC.Retrieval(ctx, userID, &req)
	if err != nil {
		c.JSON(consts.StatusOK, &external_knowledge.RetrievalResponse{
			Code: 500,
			Msg:  err.Error(),
		})
		return
	}

	c.JSON(consts.StatusOK, resp)
}
