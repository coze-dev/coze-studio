// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/coze-dev/coze-studio/backend/infra/impl/telemetry/clickhouse/internal/model"
)

func newSpansIndex(db *gorm.DB, opts ...gen.DOOption) spansIndex {
	_spansIndex := spansIndex{}

	_spansIndex.spansIndexDo.UseDB(db, opts...)
	_spansIndex.spansIndexDo.UseModel(&model.SpansIndex{})

	tableName := _spansIndex.spansIndexDo.TableName()
	_spansIndex.ALL = field.NewAsterisk(tableName)
	_spansIndex.SpanID = field.NewString(tableName, "span_id")
	_spansIndex.TraceID = field.NewString(tableName, "trace_id")
	_spansIndex.ParentSpanID = field.NewString(tableName, "parent_span_id")
	_spansIndex.Name = field.NewString(tableName, "name")
	_spansIndex.Kind = field.NewInt8(tableName, "kind")
	_spansIndex.StatusCode = field.NewInt64(tableName, "status_code")
	_spansIndex.StatusMsg = field.NewString(tableName, "status_msg")
	_spansIndex.LogID = field.NewString(tableName, "log_id")
	_spansIndex.SpaceID = field.NewInt64(tableName, "space_id")
	_spansIndex.Type = field.NewInt32(tableName, "type")
	_spansIndex.UserID = field.NewInt64(tableName, "user_id")
	_spansIndex.EntityID = field.NewInt64(tableName, "entity_id")
	_spansIndex.Env = field.NewString(tableName, "env")
	_spansIndex.Version = field.NewString(tableName, "version")
	_spansIndex.Input = field.NewString(tableName, "input")
	_spansIndex.StartTimeMs = field.NewUint64(tableName, "start_time_ms")

	_spansIndex.fillFieldMap()

	return _spansIndex
}

type spansIndex struct {
	spansIndexDo

	ALL          field.Asterisk
	SpanID       field.String
	TraceID      field.String
	ParentSpanID field.String
	Name         field.String
	Kind         field.Int8
	StatusCode   field.Int64
	StatusMsg    field.String
	LogID        field.String
	SpaceID      field.Int64
	Type         field.Int32
	UserID       field.Int64
	EntityID     field.Int64
	Env          field.String
	Version      field.String
	Input        field.String
	StartTimeMs  field.Uint64

	fieldMap map[string]field.Expr
}

func (s spansIndex) Table(newTableName string) *spansIndex {
	s.spansIndexDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s spansIndex) As(alias string) *spansIndex {
	s.spansIndexDo.DO = *(s.spansIndexDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *spansIndex) updateTableName(table string) *spansIndex {
	s.ALL = field.NewAsterisk(table)
	s.SpanID = field.NewString(table, "span_id")
	s.TraceID = field.NewString(table, "trace_id")
	s.ParentSpanID = field.NewString(table, "parent_span_id")
	s.Name = field.NewString(table, "name")
	s.Kind = field.NewInt8(table, "kind")
	s.StatusCode = field.NewInt64(table, "status_code")
	s.StatusMsg = field.NewString(table, "status_msg")
	s.LogID = field.NewString(table, "log_id")
	s.SpaceID = field.NewInt64(table, "space_id")
	s.Type = field.NewInt32(table, "type")
	s.UserID = field.NewInt64(table, "user_id")
	s.EntityID = field.NewInt64(table, "entity_id")
	s.Env = field.NewString(table, "env")
	s.Version = field.NewString(table, "version")
	s.Input = field.NewString(table, "input")
	s.StartTimeMs = field.NewUint64(table, "start_time_ms")

	s.fillFieldMap()

	return s
}

func (s *spansIndex) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *spansIndex) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 16)
	s.fieldMap["span_id"] = s.SpanID
	s.fieldMap["trace_id"] = s.TraceID
	s.fieldMap["parent_span_id"] = s.ParentSpanID
	s.fieldMap["name"] = s.Name
	s.fieldMap["kind"] = s.Kind
	s.fieldMap["status_code"] = s.StatusCode
	s.fieldMap["status_msg"] = s.StatusMsg
	s.fieldMap["log_id"] = s.LogID
	s.fieldMap["space_id"] = s.SpaceID
	s.fieldMap["type"] = s.Type
	s.fieldMap["user_id"] = s.UserID
	s.fieldMap["entity_id"] = s.EntityID
	s.fieldMap["env"] = s.Env
	s.fieldMap["version"] = s.Version
	s.fieldMap["input"] = s.Input
	s.fieldMap["start_time_ms"] = s.StartTimeMs
}

func (s spansIndex) clone(db *gorm.DB) spansIndex {
	s.spansIndexDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s spansIndex) replaceDB(db *gorm.DB) spansIndex {
	s.spansIndexDo.ReplaceDB(db)
	return s
}

type spansIndexDo struct{ gen.DO }

type ISpansIndexDo interface {
	gen.SubQuery
	Debug() ISpansIndexDo
	WithContext(ctx context.Context) ISpansIndexDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISpansIndexDo
	WriteDB() ISpansIndexDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISpansIndexDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISpansIndexDo
	Not(conds ...gen.Condition) ISpansIndexDo
	Or(conds ...gen.Condition) ISpansIndexDo
	Select(conds ...field.Expr) ISpansIndexDo
	Where(conds ...gen.Condition) ISpansIndexDo
	Order(conds ...field.Expr) ISpansIndexDo
	Distinct(cols ...field.Expr) ISpansIndexDo
	Omit(cols ...field.Expr) ISpansIndexDo
	Join(table schema.Tabler, on ...field.Expr) ISpansIndexDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISpansIndexDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISpansIndexDo
	Group(cols ...field.Expr) ISpansIndexDo
	Having(conds ...gen.Condition) ISpansIndexDo
	Limit(limit int) ISpansIndexDo
	Offset(offset int) ISpansIndexDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISpansIndexDo
	Unscoped() ISpansIndexDo
	Create(values ...*model.SpansIndex) error
	CreateInBatches(values []*model.SpansIndex, batchSize int) error
	Save(values ...*model.SpansIndex) error
	First() (*model.SpansIndex, error)
	Take() (*model.SpansIndex, error)
	Last() (*model.SpansIndex, error)
	Find() ([]*model.SpansIndex, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SpansIndex, err error)
	FindInBatches(result *[]*model.SpansIndex, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SpansIndex) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISpansIndexDo
	Assign(attrs ...field.AssignExpr) ISpansIndexDo
	Joins(fields ...field.RelationField) ISpansIndexDo
	Preload(fields ...field.RelationField) ISpansIndexDo
	FirstOrInit() (*model.SpansIndex, error)
	FirstOrCreate() (*model.SpansIndex, error)
	FindByPage(offset int, limit int) (result []*model.SpansIndex, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISpansIndexDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s spansIndexDo) Debug() ISpansIndexDo {
	return s.withDO(s.DO.Debug())
}

func (s spansIndexDo) WithContext(ctx context.Context) ISpansIndexDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s spansIndexDo) ReadDB() ISpansIndexDo {
	return s.Clauses(dbresolver.Read)
}

func (s spansIndexDo) WriteDB() ISpansIndexDo {
	return s.Clauses(dbresolver.Write)
}

func (s spansIndexDo) Session(config *gorm.Session) ISpansIndexDo {
	return s.withDO(s.DO.Session(config))
}

func (s spansIndexDo) Clauses(conds ...clause.Expression) ISpansIndexDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s spansIndexDo) Returning(value interface{}, columns ...string) ISpansIndexDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s spansIndexDo) Not(conds ...gen.Condition) ISpansIndexDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s spansIndexDo) Or(conds ...gen.Condition) ISpansIndexDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s spansIndexDo) Select(conds ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s spansIndexDo) Where(conds ...gen.Condition) ISpansIndexDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s spansIndexDo) Order(conds ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s spansIndexDo) Distinct(cols ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s spansIndexDo) Omit(cols ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s spansIndexDo) Join(table schema.Tabler, on ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s spansIndexDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s spansIndexDo) RightJoin(table schema.Tabler, on ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s spansIndexDo) Group(cols ...field.Expr) ISpansIndexDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s spansIndexDo) Having(conds ...gen.Condition) ISpansIndexDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s spansIndexDo) Limit(limit int) ISpansIndexDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s spansIndexDo) Offset(offset int) ISpansIndexDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s spansIndexDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISpansIndexDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s spansIndexDo) Unscoped() ISpansIndexDo {
	return s.withDO(s.DO.Unscoped())
}

func (s spansIndexDo) Create(values ...*model.SpansIndex) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s spansIndexDo) CreateInBatches(values []*model.SpansIndex, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s spansIndexDo) Save(values ...*model.SpansIndex) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s spansIndexDo) First() (*model.SpansIndex, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpansIndex), nil
	}
}

func (s spansIndexDo) Take() (*model.SpansIndex, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpansIndex), nil
	}
}

func (s spansIndexDo) Last() (*model.SpansIndex, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpansIndex), nil
	}
}

func (s spansIndexDo) Find() ([]*model.SpansIndex, error) {
	result, err := s.DO.Find()
	return result.([]*model.SpansIndex), err
}

func (s spansIndexDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SpansIndex, err error) {
	buf := make([]*model.SpansIndex, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s spansIndexDo) FindInBatches(result *[]*model.SpansIndex, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s spansIndexDo) Attrs(attrs ...field.AssignExpr) ISpansIndexDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s spansIndexDo) Assign(attrs ...field.AssignExpr) ISpansIndexDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s spansIndexDo) Joins(fields ...field.RelationField) ISpansIndexDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s spansIndexDo) Preload(fields ...field.RelationField) ISpansIndexDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s spansIndexDo) FirstOrInit() (*model.SpansIndex, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpansIndex), nil
	}
}

func (s spansIndexDo) FirstOrCreate() (*model.SpansIndex, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SpansIndex), nil
	}
}

func (s spansIndexDo) FindByPage(offset int, limit int) (result []*model.SpansIndex, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s spansIndexDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s spansIndexDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s spansIndexDo) Delete(models ...*model.SpansIndex) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *spansIndexDo) withDO(do gen.Dao) *spansIndexDo {
	s.DO = *do.(*gen.DO)
	return s
}
